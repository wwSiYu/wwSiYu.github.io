<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SprngMVC工作原理</title>
      <link href="/2020/05/01/11/"/>
      <url>/2020/05/01/11/</url>
      
        <content type="html"><![CDATA[<p><font color="pink">工作原理图:</font><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/uactX2Y3x9oFlfG.jpg" alt>  </p><h1><span id="一-springmvc执行流程"><font color="green">一、SpringMVC执行流程</font></span></h1><ol><li>用户发送请求至前端控制器DispatcherServlet。  </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。  </li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。  </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。  </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)</li><li>Controller执行完成返回ModelAndView。</li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</li><li>DispatcherServlet响应用户。  <h1><span id="二-组件说明"><font color="green">二、组件说明</font></span></h1>以下组件通常使用框架提供实现：  </li></ol><p>DispatcherServlet：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。 </p><p>HandlerMapping：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。   </p><p>HandlAdapter：通过扩展处理器适配器，支持更多类型的处理器。</p><p>ViewResolver：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。<br><font color="red">组件：</font><br><strong>1. 前端控制器DispatcherServlet（不需要工程师开发）,由框架提供</strong>  </p><pre><code>作用：接收请求，响应结果，相当于转发器，中央处理器。有了dispatcherServlet减少了其它组件之间的耦合度。  用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。  </code></pre><p><strong>2. 处理器映射器HandlerMapping(不需要工程师开发),由框架提供</strong></p><pre><code>作用：根据请求的url查找HandlerHandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。  </code></pre><p><strong>3. 处理器适配器HandlerAdapter</strong>  </p><pre><code>作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。  </code></pre><p><strong>4. 处理器Handler<font color="red">(需要工程师开发)</font></strong>  </p><pre><code>&lt;font color=red&gt;注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler&lt;/font&gt;  Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要工程师根据业务需求开发Handler。  </code></pre><p><strong>5. 视图解析器View resolver(不需要工程师开发),由框架提供</strong><br>    作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）<br>    View Resolver负责将处理结果生成View视图，View Resolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。<br>    一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由工程师根据业务需求开发具体的页面。</p><p><strong>6. 视图View(需要工程师开发jsp…)</strong><br>    View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…）  </p><h2><span id="核心架构的具体流程步骤如下"><font color="green">核心架构的具体流程步骤如下：</font></span></h2><ol><li><p>首先用户发送请求——&gt;DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；  </p></li><li><p>DispatcherServlet——&gt;HandlerMapping， HandlerMapping 将会把请求映射为HandlerExecutionChain 对象（包含一个Handler 处理器（页面控制器）对象、多个HandlerInterceptor 拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p></li><li><p>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter 将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p></li><li><p>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter 将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView 对象（包含模型数据、逻辑视图名）；</p></li><li><p>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver 将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；  </p></li><li><p>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</p></li><li><p>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。<br> 下边两个组件通常情况下需要开发：</p><p><font color="green"> Handler：处理器，即后端控制器用controller表示。 </font></p><p> View：视图，即展示给用户的界面，视图中通常需要标签语言展示模型数据。  </p><h2><span id="在将springmvc之前先来看一下什么是mvc模式"><font color="green">在将SpringMVC之前先来看一下什么是MVC模式</font></span></h2><p>MVC：MVC是一种设计模式  </p></li></ol><p>MVC的原理图:<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/TMdlLCmDJp8IEXh.jpg" alt><br><strong>分析：</strong><br>M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） </p><p>V-View 视图（做界面的展示  jsp，html……）  </p><p>C-Controller 控制器（接收请求—&gt;调用模型—&gt;根据结果派发页面）  </p><p><strong>springMVC是什么：</strong><br>　　springMVC是一个MVC的开源框架，springMVC=struts2+spring，springMVC就相当于是Struts2加上sring的整合，但是这里有一个疑惑就是，springMVC和spring是什么样的关系呢？这个在百度百科上有一个很好的解释：意思是说，springMVC是spring的一个后续产品，其实就是spring在原有基础上，又提供了web应用的MVC模块，可以简单的把springMVC理解为是spring的一个模块（类似AOP，IOC这样的模块），网络上经常会说springMVC和spring无缝集成，其实springMVC就是spring的一个子模块，所以根本不需要同spring进行整合。  </p><h2><span id="springmvc的原理图"><font color="green">SpringMVC的原理图：</font></span></h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/5M2S8FhZ9xHUJcP.jpg" alt>  </p><h2><span id="看到这个图大家可能会有很多的疑惑现在我们来看一下这个图的步骤可以对比mvc的原理图进行理解"><font color="green">看到这个图大家可能会有很多的疑惑，现在我们来看一下这个图的步骤：（可以对比MVC的原理图进行理解）</font></span></h2><p>第一步:用户发起请求到前端控制器（DispatcherServlet）  </p><p>第二步：前端控制器请求处理器映射器（HandlerMappering）去查找处理器（Handle）：通过xml配置或者注解进行查找  </p><p>第三步：找到以后处理器映射器（HandlerMappering）像前端控制器返回执行链（HandlerExecutionChain）  </p><p>第四步：前端控制器（DispatcherServlet）调用处理器适配器（HandlerAdapter）去执行处理器（Handler）  </p><p>第五步：处理器适配器去执行Handler  </p><p>第六步：Handler执行完给处理器适配器返回ModelAndView  </p><p>第七步：处理器适配器向前端控制器返回ModelAndView  </p><p>第八步：前端控制器请求视图解析器（ViewResolver）去进行视图解析  </p><p>第九步：视图解析器像前端控制器返回View  </p><p>第十步：前端控制器对视图进行渲染  </p><p>第十一步：前端控制器向用户响应结果</p><h2><span id="看到这些步骤我相信大家很感觉非常的乱这是正常的但是这里主要是要大家理解springmvc中的几个组件"><font color="green">看到这些步骤我相信大家很感觉非常的乱，这是正常的，但是这里主要是要大家理解springMVC中的几个组件</font></span></h2><p>前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。  </p><p>处理器映射器（HandlerMapping）：根据URL去查找处理器  </p><p>处理器（Handler）：（需要程序员去写代码处理逻辑的）  </p><p>处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）  </p><p>视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面</p><hr><h2><span id="完结">完结…</span></h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/zeXHx4D2vJWwILV.jpg" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
            <tag> 工作原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL语句</title>
      <link href="/2020/04/30/di-er-pian/"/>
      <url>/2020/04/30/di-er-pian/</url>
      
        <content type="html"><![CDATA[<h1><span id="sql语句大全">SQL语句大全</span></h1><hr><h2><span id="一-基础">一、基础</span></h2><ol><li>说明：创建数据库<br><font color="gree">CREATE DATABASE database-name</font></li><li>说明：删除数据库<br><font color="gree">drop database dbname</font></li><li>说明：备份sql server  <ul><li>创建 备份数据的 device<br><font color="gree"> USE master<br>EXEC sp_addumpdevice ‘disk’, ‘testBack’, ‘c:\mssql7backup\MyNwind_1.dat’ </font> </li><li>开始备份<br><font color="gree">BACKUP DATABASE pubs TO testBack </font><ol start="4"><li>说明：创建新表</li></ol></li><li>根据已有的表创建新表<br><font color="gree">A：create table tab_new like tab_old </font>(使用旧表创建新表)<br><font color="gree">B：create table tab_new as select col1,col2… from tab_old definition only</font></li></ul></li><li>说明：删除新表<br><font color="gree">drop table tabname  </font></li><li>说明：增加一个列<br><font color="gree">Alter table tabname add column col type</font><br><font color="red">注:</font>列增加后将不能删除。DB2中列加上后数据类型也不能改变，唯一能改变的是增加varchar类型的长度  </li><li>说明：添加主键<br><font color="gree">Alter table tabname add primary key(col)</font><br>说明：删除主键<br><font color="gree">Alter table tabname drop primary key(col)</font>  </li><li>说明：创建索引<br><font color="gree">create [unique] index idxname on tabname(col….) </font><br>删除索引<br><font color="gree">drop index idxname</font><br><font color="red">  注: </font>索引是不可更改的，想更改必须删除重新建</li><li>说明：创建视图<br><font color="gree">create view viewname as select statement</font><br>删除视图<br><font color="gree">drop view viewname</font></li><li>说明：几个简单的基本的sql语句<br>选择：<font color="gree">select * from table1 where 范围</font><br>删除：<font color="gree">delete from table1 where 范围</font><br>更新：<font color="gree">update table1 set field1=value1 where 范围</font><br>查找：<font color="gree">select * from table1 where field1 like ’%value1%’</font>—like的语法很精妙，查资料!<br>排序：<font color="gree">select * from table1 order by field1,field2 [desc]</font><br>总数：<font color="gree">select count as totalcount from </font><br>求和：<font color="gree">select sum(field1) as sumvalue from table1</font><br>平均：<font color="gree">select avg(field1) as avgvalue from table1</font><br>最大：<font color="gree">select max(field1) as maxvalue from table1</font><br>最小：<font color="gree">select min(field1) as minvalue from table1</font>  </li><li>说明：几个高级查询运算词<br>A： UNION 运算符<br><font color="green">UNION 运算符通过组合其他两个结果表（例如 TABLE1 和 TABLE2）并消去表中任何重复行而派生出一个结果表。当 ALL 随 UNION 一起使用时（即 UNION ALL），不消除重复行。两种情况下，派生表的每一行不是来自 TABLE1 就是来自 TABLE2。 </font><br>B： EXCEPT 运算符<br><font color="green">EXCEPT运算符通过包括所有在 TABLE1 中但不在 TABLE2 中的行并消除所有重复行而派生出一个结果表。当 ALL 随 EXCEPT 一起使用时 (EXCEPT ALL)，不消除重复行</font><br>C： INTERSECT 运算符<br><font color="green">INTERSECT运算符通过只包括 TABLE1 和 TABLE2 中都有的行并消除所有重复行而派生出一个结果表。当 ALL随 INTERSECT 一起使用时 (INTERSECT ALL)，不消除重复行。<br><font color="red">注: </font>使用运算词的几个查询结果行必须是一致的。</font>  </li><li>说明：使用外连接<br>A: left （outer） join：<br><font color="pink">左外连接（左连接）：结果集几包括连接表的匹配行，也包括左连接表的所有行。<br>SQL: select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</font><br>B：right （outer） join:<br><font color="pink">右外连接(右连接)：结果集既包括连接表的匹配连接行，也包括右连接表的所有行</font><br>C：full/cross （outer） join：<br><font color="pink">全外连接：不仅包括符号连接表的匹配行，还包括两个连接表中的所有记录。</font>  </li><li>分组:Group by:<br><font color="green">  一张表，一旦分组 完成后，查询后只能得到组相关的信息。<br>组相关的信息：（统计信息） count,sum,max,min,avg  分组的标准)<br>在SQLServer中分组时：不能以text,ntext,image类型的字段作为分组依据<br>在selecte统计函数中的字段，不能和普通的字段放在一起；</font>  </li><li>对数据库进行操作:<br><font color="green"> 分离数据库： sp_detach_db;附加数据库：sp_attach_db 后接表明，附加需要完整的路径名</font>  </li><li>如何修改数据库的名称:<br><font color="pink">sp_renamedb ‘old_name’, ‘new_name’</font></li></ol><hr><h2><span id="二-提升">二、提升</span></h2><ol><li><p>说明：复制表(只复制结构,源表名：a 新表名：b) (Access可用)<br>法一：<font color="gree">select * into b from a where 1&lt;&gt;1（仅用于SQlServer）  </font><br>法二：<font color="gree">select top 0 * into b from a</font>  </p></li><li><p>说明：拷贝表(拷贝数据,源表名：a 目标表名：b) (Access可用)<br><font color="gree">insert into b(a, b, c) select d,e,f from b;</font>  </p></li><li><p>说明：跨数据库之间表的拷贝(具体数据使用绝对路径) (Access可用)<br><font color="gree">insert into b(a, b, c) select d,e,f from b in ‘具体数据库’ where 条件</font><br><font color="pink">例子：..from b in ‘“&amp;Server.MapPath(“.”)&amp;”\data.mdb” &amp;”‘ where.</font>  </p></li><li><p>说明：子查询(表名1：a 表名2：b)<br><font color="gree">select a,b,c from a where a IN (select d from b )</font><br>或者:<font color="gree"> select a,b,c from a where a IN (1,2,3) </font>  </p></li><li><p>说明：显示文章、提交人和最后回复时间<br><font color="gree">select a.title,a.username,b.adddate from table a,(select max(adddate) adddate from table where table.title=a.title) b</font>  </p></li><li><p>说明：外连接查询(表名1：a 表名2：b)<br><font color="gree">select a.a, a.b, a.c, b.c, b.d, b.f from a LEFT OUT JOIN b ON a.a = b.c</font>  </p></li><li><p>说明：在线视图查询(表名1：a )<br><font color="gree">select * from (SELECT a,b,c FROM a) T where t.a &gt; 1;</font>  </p></li><li><p>说明：between的用法,between限制查询数据范围时包括了边界值,not between不包括<br><font color="gree">select * from table1 where time between time1 and time2</font><br><font color="gree">select a,b,c, from table1 where a not between 数值1 and 数值2</font>  </p></li><li><p>说明：in 的使用方法<br><font color="gree">select * from table1 where a [not] in (‘值1’,’值2’,’值4’,’值6’)</font>  </p></li><li><p>说明：两张关联表，删除主表中已经在副表中没有的信息<br><font color="gree">delete from table1 where not exists ( select * from table2 where table1.field1=table2.field1 )</font>  </p></li><li><p>说明：四表联查问题：<br><font color="gree">select * from a left inner join b on a.a=b.b right inner join c on a.a=c.c inner join d on a.a=d.d where …..</font>  </p></li><li><p>说明：日程安排提前五分钟提醒<br>SQL: <font color="gree">select * from 日程安排 where datediff(‘minute’,f开始时间,getdate())&gt;5</font>  </p></li><li><p>说明：一条sql 语句搞定数据库分页select top 10 b.* from (select top 20 主键字段,排序字段 from 表名 order by 排序字段 desc) a,表名 b where b.主键字段 = a.主键字段 order by a.排序字段具体实现：关于数据库分页:  </p><pre><code>    declare @start int,@end int    @sql  nvarchar(600)    set @sql=’select top’+str(@end-@start+1)+’+from T where rid not in(select top’+str(@str-1)+’Rid from T where Rid&gt;-1)’    exec sp_executesql @sql    注意：在top后不能直接跟一个变量，所以在实际应用中只有这样的进行特殊的处理。Rid为一个标识列，如果top后还有具体的字段，这样做是非常有好处的。因为这样可以避免 top的字段如果是逻辑索引的，查询的结果后实际表中的不一致（逻辑索引中的数据有可能和数据表中的不一致，而查询时如果处在索引则首先查询索引）  </code></pre></li><li><p>说明：前10条记录<br><font color="gree">select top 10 * form table1 where 范围 </font>  </p></li><li><p>说明：选择在每一组b值相同的数据中对应的a最大的记录的所有信息(类似这样的用法可以用于论坛每月排行榜,每月热销产品分析,按科目成绩排名,等等.)<br><font color="gree">select a,b,c from tablename ta where a=(select max(a) from tablename tb where tb.b=ta.b)</font>  </p></li><li><p>说明：包括所有在 TableA中但不在 TableB和TableC中的行并消除所有重复行而派生出一个结果表<br><font color="gree">(select a from tableA ) except (select a from tableB) except (select a from tableC)</font>  </p></li><li><p>说明：随机取出10条数据<br><font color="gree">select top 10 * from tablename order by newid()</font>  </p></li><li><p>说明：随机选择记录<br><font color="gree">select newid()</font>  </p></li><li><p>说明：删除重复记录<br>1),<font color="gree">delete from tablename where id not in (select max(id) from tablename group by col1,col2,…)</font><br>2),<font color="gree">select distinct * into temp from tablename<br>delete from tablename<br>insert into tablename select * from temp</font><br><font color="pink">评价： 这种操作牵连大量的数据的移动，这种做法不适合大容量但数据操作3),例如：在一个外部表中导入数据，由于某些原因第一次只导入了一部分，但很难判断具体位置，这样只有在下一次全部导入，这样也就产生好多重复的字段，怎样删除重复字段</font><br><font color="gree">alter table tablename</font><br>–添加一个自增列<br><font color="pink">add  column_b int identity(1,1)<br>delete from tablename where column_b not in(<br>select max(column_b)  from tablename group by column1,column2,…)<br>alter table tablename drop column column_b</font>  </p></li><li><p>说明：列出数据库里所有的表名<br><font color="gree">select name from sysobjects where type=’U’</font> // U代表用户  </p></li><li><p>说明：列出表里的所有的列名<br><font color="gree">select name from syscolumns where id=object_id(‘TableName’)</font>   </p></li><li><p>说明：列示type、vender、pcs字段，以type字段排列，case可以方便地实现多重选择，类似select 中的case。<br><font color="gree">select type,sum(case vender when ‘A’ then pcs else 0 end),sum(case vender when ‘C’ then pcs else 0 end),sum(case vender when ‘B’ then pcs else 0 end) FROM tablename group by type</font><br>显示结果：<br><font color="red">type vender pcs<br>电脑 A 1<br>电脑 A 1<br>光盘 B 2<br>光盘 A 2<br>手机 B 3<br>手机 C 3</font>   </p></li><li><p>说明：初始化表table1<br><font color="gree">TRUNCATE TABLE table1</font>  </p></li><li><p>说明：选择从10到15的记录<br><font color="gree">select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc</font>  </p></li></ol><hr><h2><span id="三-技巧">三、技巧</span></h2><ol><li><p>1=1，1=2的使用，在SQL语句组合时用的较多  </p><p>   “where 1=1” 是表示选择全部    “where 1=2”全部不选，<br>   如：<br>   <font color="pink">if @strWhere !=’’<br>   begin<br>   set @strSQL = ‘select count(<em>) as Total from [‘ + @tblName + ‘] where ‘ + @strWhere<br>   end<br>   else<br>   begin<br>   set @strSQL = ‘select count(</em>) as Total from [‘ + @tblName + ‘]’<br>   end</font>  </p><p>   我们可以直接写成</p><p>   错误！未找到目录项。<br>   <font color="pink">set @strSQL = ‘select count(*) as Total from [‘ + @tblName + ‘] where 1=1 安定 ‘+ @strWhere</font>  </p></li><li><p>收缩数据库  </p></li></ol><p>–重建索引<br><font color="gree">DBCC REINDEX<br>DBCC INDEXDEFRAG</font><br>–收缩数据和日志<br><font color="gree">DBCC SHRINKDB<br>DBCC SHRINKFILE</font><br>3.  压缩数据库<br><font color="gree">dbcc shrinkdatabase(dbname) </font><br>4. 转移数据库给新用户以已存在用户权限<br><font color="gree">exec sp_change_users_login ‘update_one’,’newname’,’oldname’ go</font><br>5. 检查备份集<br><font color="gree">RESTORE VERIFYONLY from disk=’E:\dvbbs.bak’</font><br>6. 修复数据库<br><font color="pink">ALTER DATABASE [dvbbs] SET SINGLE_USER<br>GO<br>DBCC CHECKDB(‘dvbbs’,repair_allow_data_loss) WITH TABLOCK<br>GO<br>ALTER DATABASE [dvbbs] SET MULTI_USER<br>GO</font><br>7. 日志清除<br><font color="pink">SET NOCOUNT ON<br>DECLARE @LogicalFileName sysname,<br> @MaxMinutes INT,<br> @NewSize INT </font>  </p><pre><code>    USE tablename -- 要操作的数据库名      SELECT  @LogicalFileName = 'tablename_log', -- 日志文件名      @MaxMinutes = 10, -- Limit on time allowed to wrap log.      @NewSize = 1  -- 你想设定的日志文件的大小(M)      Setup / initialize      DECLARE @OriginalSize int      SELECT @OriginalSize = size       FROM sysfiles        WHERE name = @LogicalFileName        SELECT 'Original Size of ' + db_name() + ' LOG is ' +       CONVERT(VARCHAR(30),@OriginalSize) + ' 8K pages or ' +       CONVERT(VARCHAR(30),(@OriginalSize*8/1024)) + 'MB'      FROM sysfiles      WHERE name = @LogicalFileName      CREATE TABLE DummyTrans      (DummyColumn char (8000) not null)      DECLARE @Counter    INT,      @StartTime DATETIME,        @TruncLog   VARCHAR(255)        SELECT @StartTime = GETDATE(),      @TruncLog = 'BACKUP LOG ' + db_name() + ' WITH TRUNCATE_ONLY'      DBCC SHRINKFILE (@LogicalFileName, @NewSize)      EXEC (@TruncLog)      -- Wrap the log if necessary.      WHILE @MaxMinutes &gt; DATEDIFF (mi, @StartTime, GETDATE()) -- time has not expired      AND @OriginalSize = (SELECT size FROM sysfiles WHERE name = @LogicalFileName)        AND (@OriginalSize * 8 /1024) &gt; @NewSize        BEGIN -- Outer loop.      SELECT @Counter = 0      WHILE   ((@Counter &lt; @OriginalSize / 16) AND (@Counter &lt; 50000))      BEGIN -- update      INSERT DummyTrans VALUES ('Fill Log') DELETE DummyTrans      SELECT @Counter = @Counter + 1      END      EXEC (@TruncLog)        END      SELECT 'Final Size of ' + db_name() + ' LOG is ' +      CONVERT(VARCHAR(30),size) + ' 8K pages or ' +       CONVERT(VARCHAR(30),(size*8/1024)) + 'MB'      FROM sysfiles       WHERE name = @LogicalFileName      DROP TABLE DummyTrans      SET NOCOUNT OFF  </code></pre><ol start="8"><li><p>说明：更改某个表<br><font color="pink">exec sp_changeobjectowner ‘tablename’,’dbo’</font>  </p></li><li><p>存储更改全部表  </p><pre><code>     CREATE PROCEDURE dbo.User_ChangeObjectOwnerBatch       @OldOwner as NVARCHAR(128),       @NewOwner as NVARCHAR(128)       AS   DECLARE @Name    as NVARCHAR(128)   DECLARE @Owner   as NVARCHAR(128)   DECLARE @OwnerName   as NVARCHAR(128)   DECLARE curObject CURSOR FOR    select 'Name'    = name,   'Owner'    = user_name(uid)   from sysobjects   where user_name(uid)=@OldOwner   order by name   OPEN   curObject   FETCH NEXT FROM curObject INTO @Name, @Owner   WHILE(@@FETCH_STATUS=0)   BEGIN        if @Owner=@OldOwner    begin   set @OwnerName = @OldOwner + '.' + rtrim(@Name)   exec sp_changeobjectowner @OwnerName, @NewOwner   end   -- select @name,@NewOwner,@OldOwner   FETCH NEXT FROM curObject INTO @Name, @Owner   END   close curObject   deallocate curObject   GO  </code></pre></li><li><p>SQL SERVER中直接循环写入数据  </p><pre><code>declare @i int  set @i=1  while @i&lt;30  begin  insert into test (userid) values(@i)  set @i=@i+1  end  案例：  有如下表，要求就裱中所有沒有及格的成績，在每次增長0.1的基礎上，使他們剛好及格:  Name     score  Zhangshan   80  Lishi       59  Wangwu      50  Songquan    69  while((select min(score) from tb_table)&lt;60)  begin  update tb_table set score =score*1.01  where score&lt;60  if  (select min(score) from tb_table)&gt;60  break  else  continue  end  </code></pre></li></ol><hr><h2><span id="数据开发-经典">数据开发-经典</span></h2><ol><li><p>按姓氏笔画排序:<br>Select * From TableName Order By CustomerName Collate Chinese_PRC_Stroke_ci_as //从少到多  </p></li><li><p>数据库加密:<br>select encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同；否则不相同 encrypt(‘原始密码’)<br>select pwdencrypt(‘原始密码’)<br>select pwdcompare(‘原始密码’,’加密后密码’) = 1–相同；否则不相同  </p></li><li><p>取回表中字段:<br>declare @list varchar(1000),<br>@sql nvarchar(1000)<br>select @list=@list+’,’+b.name from sysobjects a,syscolumns b where a.id=b.id and<br>a.name=’表A’<br>set @sql=’select ‘+right(@list,len(@list)-1)+’ from 表A’<br>exec (@sql)  </p></li><li><p>查看硬盘分区:<br>EXEC master..xp_fixeddrives    </p></li><li><p>杀掉所有的事件探察器进程:<br>DECLARE hcforeach CURSOR GLOBAL FOR SELECT ‘kill ‘+RTRIM(spid) FROM   master.dbo.sysprocesses<br>WHERE program_name IN(‘SQL profiler’,N’SQL 事件探查器’)<br>EXEC sp_msforeach_worker ‘?’  </p></li><li><p>获取当前数据库中的所有用户表<br>select Name from sysobjects where xtype=’u’ and status&gt;=0  </p></li><li><p>获取某一个表的所有字段<br> select name from syscolumns where id=object_id(‘表名’)  </p><p> select name from syscolumns where id in (select id from sysobjects where type = ‘u’ and name = ‘表名’)  </p><p> 两种方式的效果相同  </p></li><li><p>查看与某一个表相关的视图、存储过程、函数select a.* from sysobjects a, syscomments b where a.id = b.id and b.text like ‘%表名%’  </p></li><li><p>查看当前数据库中所有存储过程<br>select name as 存储过程名称 from sysobjects where xtype=’P’  </p></li><li><p>查询用户创建的所有数据库select * from master..sysdatabases D where sid not in(select sid from master..syslogins where name=’sa’)<br>或者<br>select dbid, name AS DB_NAME from master..sysdatabases where sid &lt;&gt; 0x01  </p></li><li><p>询某一个表的字段和数据类型<br>select column_name,data_type from information_schema.columns<br>where table_name = ‘表名’   </p></li></ol><hr><h2><span id="完结">完结…</span></h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/mugFGOJjI1Mq8yT.jpg" alt="biu"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL语句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2020/04/30/di-yi-pian-bo-ke/"/>
      <url>/2020/04/30/di-yi-pian-bo-ke/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://i.loli.net/2020/05/01/JmhB5PHgnOj1E9G.jpg" alt></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> DEMO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
